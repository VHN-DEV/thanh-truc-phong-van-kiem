<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>72 Thanh Trúc Phong Vân Kiếm – Zoomable</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        html, body {
            margin: 0; padding: 0;
            background: radial-gradient(circle at center, #0a1525, #000);
            overflow: hidden;
            cursor: none;
            touch-action: none;
        }
        canvas { display: block; }
        /* Hướng dẫn sử dụng nhỏ ở góc */
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.3);
            font-family: monospace;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="ui">Scroll to Zoom • Double Tap to Change Form</div>

<script>
    /**
     * ====================================================================
     * 1. CONFIGURATION
     * ====================================================================
     */
    const CONFIG = {
        CORE: { BASE_WIDTH: 1920 },
        ZOOM: {
            MIN: 0.5,           // Thu nhỏ tối đa
            MAX: 3.0,           // Phóng to tối đa
            SENSITIVITY: 0.001, // Độ nhạy khi lăn chuột
            SMOOTH: 0.1         // Độ mượt (0.1 = chậm, 1 = tức thì)
        },
        SWORD: {
            COUNT: 72,
            BASE_RADIUS: 130,
            LAYER_SPACING: 70,
            SPIN_SPEED_BASE: 0.07,
            ATTACK_DELAY_MS: 180,
            TRAIL_LENGTH: 6,
            SIZE: 70,
        },
        INPUT: { DOUBLE_TAP_DELAY: 300 },
        COLORS: {
            BG_FADE: "rgba(0, 0, 8, 0.25)",
            SWORD_BLADE: ["#d0fff5", "#7fdcc0", "#3fa78a"],
            SWORD_TRAIL: "rgba(120, 255, 210, 0.3)",
        },
        ENEMY: {
            SPAWN_COUNT: 6,
            PALETTES: [
                ["#ff9999", "#cc3333"], ["#99ccff", "#3366cc"],
                ["#99ff99", "#33cc33"], ["#ffcc99", "#cc6600"],
                ["#ff99ff", "#cc33cc"], ["#ffff99", "#cccc33"]
            ]
        }
    };

    /**
     * ====================================================================
     * 2. SYSTEM & CAMERA
     * ====================================================================
     */
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });
    
    let scaleFactor = 1;
    let width, height;

    // Camera Object để quản lý Zoom
    const Camera = {
        currentZoom: 1,
        targetZoom: 1,
        
        update() {
            // Hiệu ứng easing (làm mượt)
            this.currentZoom += (this.targetZoom - this.currentZoom) * CONFIG.ZOOM.SMOOTH;
        },

        // Chuyển đổi tọa độ màn hình sang tọa độ thế giới game
        // Screen -> World
        screenToWorld(screenX, screenY) {
            const centerX = width / 2;
            const centerY = height / 2;
            return {
                x: (screenX - centerX) / this.currentZoom + centerX,
                y: (screenY - centerY) / this.currentZoom + centerY
            };
        }
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        scaleFactor = width / CONFIG.CORE.BASE_WIDTH;
    }
    window.addEventListener("resize", resize);
    resize();

    const random = (min, max) => Math.random() * (max - min) + min;

    /**
     * ====================================================================
     * 3. INPUT HANDLER (UPDATED FOR ZOOM)
     * ====================================================================
     */
    const Input = {
        screenX: width / 2, screenY: height / 2, // Tọa độ thực trên màn hình
        x: width / 2, y: height / 2,             // Tọa độ logic trong game (đã tính zoom)
        px: 0, py: 0,
        speed: 0,
        isAttacking: false,
        guardForm: 1,
        lastTapTime: 0,
        attackTimer: null,

        update() {
            // Cập nhật tọa độ logic dựa trên camera hiện tại
            const worldPos = Camera.screenToWorld(this.screenX, this.screenY);
            this.x = worldPos.x;
            this.y = worldPos.y;

            this.speed = Math.hypot(this.x - this.px, this.y - this.py);
            this.px = this.x; 
            this.py = this.y;
        },

        handleMove(e) {
            e.preventDefault();
            const p = e.touches ? e.touches[0] : e;
            this.screenX = p.clientX;
            this.screenY = p.clientY;
        },

        handleDown(e) {
            e.preventDefault();
            const now = performance.now();
            if (now - this.lastTapTime < CONFIG.INPUT.DOUBLE_TAP_DELAY) {
                this.guardForm = this.guardForm === 1 ? 2 : 1;
                clearTimeout(this.attackTimer);
                this.isAttacking = false;
                this.lastTapTime = 0;
                return;
            }
            this.lastTapTime = now;
            this.attackTimer = setTimeout(() => { this.isAttacking = true; }, CONFIG.SWORD.ATTACK_DELAY_MS);
        },

        handleUp(e) {
            e.preventDefault();
            this.isAttacking = false;
            clearTimeout(this.attackTimer);
        },

        handleWheel(e) {
            // Zoom in/out dựa trên lăn chuột
            const delta = -e.deltaY * CONFIG.ZOOM.SENSITIVITY;
            Camera.targetZoom += delta;
            
            // Kẹp giá trị trong khoảng min/max
            if (Camera.targetZoom < CONFIG.ZOOM.MIN) Camera.targetZoom = CONFIG.ZOOM.MIN;
            if (Camera.targetZoom > CONFIG.ZOOM.MAX) Camera.targetZoom = CONFIG.ZOOM.MAX;
        }
    };

    ['pointermove', 'touchmove'].forEach(evt => window.addEventListener(evt, e => Input.handleMove(e), { passive: false }));
    ['pointerdown', 'touchstart'].forEach(evt => window.addEventListener(evt, e => Input.handleDown(e), { passive: false }));
    ['pointerup', 'touchend'].forEach(evt => window.addEventListener(evt, e => Input.handleUp(e), { passive: false }));
    window.addEventListener('wheel', e => Input.handleWheel(e), { passive: false });

    /**
     * ====================================================================
     * 4. GAME ENTITIES
     * ====================================================================
     */
    class Enemy {
        constructor() { this.respawn(); }
        respawn() {
            // Spawn ngẫu nhiên trong vùng rộng hơn màn hình một chút để khi zoom out vẫn thấy
            const margin = 500;
            this.x = random(-margin, width + margin);
            this.y = random(-margin, height + margin);
            this.r = (10 + Math.pow(Math.random(), 1.5) * 50) * scaleFactor; 
            this.maxHp = 1 + Math.floor(Math.random() * 100);
            this.hp = this.maxHp;
            this.colors = CONFIG.ENEMY.PALETTES[Math.floor(Math.random() * CONFIG.ENEMY.PALETTES.length)];
        }
        hit() {
            this.hp--;
            if (this.hp <= 0) { this.respawn(); return true; }
            return false;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            const g = ctx.createRadialGradient(0, 0, this.r * 0.2, 0, 0, this.r);
            g.addColorStop(0, this.colors[0]);
            g.addColorStop(1, this.colors[1]);
            ctx.beginPath();
            ctx.arc(0, 0, this.r, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.shadowColor = this.colors[1];
            ctx.shadowBlur = 15 * scaleFactor;
            ctx.fill();
            ctx.restore();
        }
    }

    class Sword {
        constructor(index) {
            this.index = index;
            this.layer = Math.floor(index / 24); 
            this.baseAngle = (Math.PI * 2 / 24) * (index % 24);
            this.spinAngle = 0;
            this.spinSpeed = (CONFIG.SWORD.SPIN_SPEED_BASE / (this.layer + 1)) * (this.layer % 2 ? -1 : 1);
            this.radius = (CONFIG.SWORD.BASE_RADIUS + this.layer * CONFIG.SWORD.LAYER_SPACING) * scaleFactor;
            this.x = Input.x; this.y = Input.y;
            this.vx = 0; this.vy = 0;
            this.drawAngle = 0;
            this.trail = [];
            this.breath = random(0, Math.PI * 2);
            this.breathSpeed = random(0.015, 0.025);
            this.attackDelay = this.layer * 6 + random(0, 10);
            this.attackFrame = 0;
        }

        update(guardCenter, enemies) {
            this.breath += this.breathSpeed;
            const currentRadius = this.radius + Math.sin(this.breath) * 8 * scaleFactor;

            if (!Input.isAttacking) {
                this.updateGuardMode(guardCenter, currentRadius);
            } else {
                this.updateAttackMode(enemies);
            }
        }

        updateGuardMode(guardCenter, r) {
            this.spinAngle += this.spinSpeed;
            const a = this.baseAngle + this.spinAngle;
            const tx = guardCenter.x + Math.cos(a) * r;
            const ty = guardCenter.y + Math.sin(a) * r;

            if (Input.speed > 3) {
                const dx = tx - this.x, dy = ty - this.y;
                const dist = Math.hypot(dx, dy) || 1;
                this.vx += (dx / dist) * Math.min(dist * 0.05, 4 * scaleFactor);
                this.vy += (dy / dist) * Math.min(dist * 0.05, 4 * scaleFactor);
                this.vx *= 0.85; this.vy *= 0.85;
                this.x += this.vx; this.y += this.vy;
                this.drawAngle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
            } else {
                if (Input.guardForm === 1) {
                    this.x += (tx - this.x) * 0.15;
                    this.y += (ty - this.y) * 0.15;
                    this.vx *= 0.3; this.vy *= 0.3;
                    this.drawAngle = a + Math.PI / 2;
                } else {
                    this.x += (tx - this.x) * 0.1;
                    this.y += (ty - this.y) * 0.1;
                    this.drawAngle = Math.atan2(ty - this.y, tx - this.x) + Math.PI / 2;
                }
            }
            this.attackFrame = 0;
            this.trail = [];
        }

        updateAttackMode(enemies) {
            this.attackFrame++;
            if (this.attackFrame < this.attackDelay) return;
            let target = null, minStartDist = Infinity;
            for (const e of enemies) {
                const d = Math.hypot(e.x - Input.x, e.y - Input.y);
                if (d < minStartDist) { minStartDist = d; target = e; }
            }
            if (target) {
                const dx = target.x - this.x, dy = target.y - this.y;
                const d = Math.hypot(dx, dy) || 1;
                this.vx += (dx / d) * 10 * scaleFactor;
                this.vy += (dy / d) * 10 * scaleFactor;
                this.vx *= 0.92; this.vy *= 0.92;
                this.x += this.vx; this.y += this.vy;
                this.drawAngle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
                if (Math.hypot(this.x - target.x, this.y - target.y) < target.r) target.hit();
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > CONFIG.SWORD.TRAIL_LENGTH) this.trail.shift();
            }
        }

        draw(ctx) {
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                ctx.strokeStyle = CONFIG.COLORS.SWORD_TRAIL;
                ctx.lineWidth = 2 * scaleFactor;
                ctx.stroke();
            }
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.drawAngle);
            this.drawAura(ctx);
            this.drawBlade(ctx);
            ctx.restore();
        }

        drawAura(ctx) {
            const auraCount = Math.floor(random(2, 4));
            ctx.shadowColor = "#fffaa0";
            ctx.shadowBlur = 8 * scaleFactor;
            for (let i = 0; i < auraCount; i++) {
                ctx.beginPath();
                let py = -random(0, CONFIG.SWORD.SIZE * scaleFactor);
                let px = random(-3, 3) * scaleFactor;
                ctx.moveTo(px, py);
                for (let s = 0; s < 3; s++) {
                    px += random(-4, 4) * scaleFactor;
                    py += random(-3, 3) * scaleFactor;
                    ctx.lineTo(px, py);
                }
                ctx.strokeStyle = `rgba(255,255,180,${random(0.3, 0.6)})`;
                ctx.lineWidth = 1.5 * scaleFactor;
                ctx.stroke();
            }
        }

        drawBlade(ctx) {
            const sLen = CONFIG.SWORD.SIZE * scaleFactor;
            const sWid = 4 * scaleFactor;
            ctx.shadowColor = "#8fffe0";
            ctx.shadowBlur = 15 * scaleFactor;
            const g = ctx.createLinearGradient(0, -sLen, 0, 0);
            g.addColorStop(0, CONFIG.COLORS.SWORD_BLADE[0]);
            g.addColorStop(0.5, CONFIG.COLORS.SWORD_BLADE[1]);
            g.addColorStop(1, CONFIG.COLORS.SWORD_BLADE[2]);
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.moveTo(-sWid / 2, 0);
            ctx.lineTo(-sWid / 2, -sLen);
            ctx.quadraticCurveTo(0, -sLen - 10 * scaleFactor, sWid / 2, -sLen);
            ctx.lineTo(sWid / 2, 0);
            ctx.fill();
            
            ctx.shadowColor = "#9fffe6";
            ctx.fillStyle = "#4fcfb2";
            ctx.beginPath();
            ctx.roundRect(-7*scaleFactor, -1.2*scaleFactor, 14*scaleFactor, 2.4*scaleFactor, 2.4*scaleFactor);
            ctx.fill();

            ctx.fillStyle = "#2f7f68";
            ctx.beginPath();
            ctx.moveTo(-3 * scaleFactor, 0);
            ctx.lineTo(-2 * scaleFactor, 14 * scaleFactor);
            ctx.lineTo(2 * scaleFactor, 14 * scaleFactor);
            ctx.lineTo(3 * scaleFactor, 0);
            ctx.fill();
        }
    }

    class StarField {
        constructor(count) {
            this.stars = [];
            // Tạo sao trên vùng rộng gấp 3 lần màn hình để khi zoom out không bị đen
            const limit = 3; 
            for(let i=0; i<count; i++) {
                this.stars.push({
                    x: random(-width, width * 2), 
                    y: random(-height, height * 2),
                    r: random(0.5, 2),
                    alpha: random(0.2, 1)
                });
            }
        }
        draw(ctx) {
            ctx.shadowBlur = 0;
            for (const s of this.stars) {
                s.alpha += random(-0.01, 0.01);
                if (s.alpha > 1) s.alpha = 1; else if (s.alpha < 0.2) s.alpha = 0.2;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r * scaleFactor, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fill();
            }
        }
    }

    /**
     * ====================================================================
     * 5. MAIN MANAGER
     * ====================================================================
     */
    const enemies = [];
    const swords = [];
    let starField;
    const guardCenter = { x: width/2, y: height/2, vx: 0, vy: 0 };

    function init() {
        starField = new StarField(250); // Tăng số lượng sao vì không gian rộng hơn
        for (let i = 0; i < CONFIG.ENEMY.SPAWN_COUNT; i++) enemies.push(new Enemy());
        for (let i = 0; i < CONFIG.SWORD.COUNT; i++) swords.push(new Sword(i));
    }

    function updatePhysics() {
        Camera.update(); // Cập nhật zoom mượt
        Input.update();  // Cập nhật tọa độ chuột dựa trên zoom

        let dx = Input.x - guardCenter.x;
        let dy = Input.y - guardCenter.y;
        guardCenter.vx += dx * 0.04; 
        guardCenter.vy += dy * 0.04;
        guardCenter.vx *= 0.82;
        guardCenter.vy *= 0.82;
        guardCenter.x += guardCenter.vx; 
        guardCenter.y += guardCenter.vy;
    }

    function renderCursor() {
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#6fffe0";
        ctx.beginPath();
        // Vẽ con trỏ tại tọa độ World (Input.x, Input.y)
        ctx.arc(Input.x, Input.y, 4 * scaleFactor, 0, Math.PI * 2);
        ctx.fillStyle = "#6fffe0";
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function animate() {
        // 1. Xóa màn hình (Vẽ nền mờ) - Ở hệ tọa độ màn hình (Screen Space)
        ctx.fillStyle = CONFIG.COLORS.BG_FADE;
        ctx.fillRect(0, 0, width, height);

        updatePhysics();

        // 2. Bắt đầu Camera Transform
        ctx.save();
        // Dời gốc về giữa màn hình -> Zoom -> Trả gốc về
        ctx.translate(width / 2, height / 2);
        ctx.scale(Camera.currentZoom, Camera.currentZoom);
        ctx.translate(-width / 2, -height / 2);

        // --- Bắt đầu vẽ thế giới game (World Space) ---
        starField.draw(ctx);
        
        ctx.save();
        ctx.translate(guardCenter.x, guardCenter.y);
        ctx.rotate(performance.now() * 0.0002);
        ctx.strokeStyle = "rgba(120,255,210,0.1)";
        ctx.lineWidth = 1.5 * scaleFactor;
        ctx.beginPath();
        ctx.arc(0, 0, 50 * scaleFactor, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        enemies.forEach(e => e.draw(ctx));
        swords.forEach(s => {
            s.update(guardCenter, enemies);
            s.draw(ctx);
        });
        renderCursor();
        // --- Kết thúc vẽ thế giới game ---

        ctx.restore(); // Kết thúc Camera Transform

        requestAnimationFrame(animate);
    }

    init();
    animate();

</script>
</body>
</html>