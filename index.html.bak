<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>72 Thanh Trúc Phong Vân Kiếm – Mobile Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        html, body {
            margin: 0; padding: 0;
            background: radial-gradient(circle at center, #0a1525, #000);
            overflow: hidden;
            cursor: none;
            touch-action: none;
        }
        canvas { display: block; }
        
        /* UI chung */
        .game-ui {
            position: absolute;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            pointer-events: none;
        }

        #instructions {
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.3);
            font-size: 12px;
        }

        /* Group điều khiển - Cho phép tương tác */
        .controls-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        .btn {
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(143, 255, 224, 0.3);
            color: #8fffe0;
            border-radius: 50%;
            backdrop-filter: blur(5px);
            -webkit-tap-highlight-color: transparent;
            active-state: scale(0.9);
        }
        .btn:active {
            background: rgba(143, 255, 224, 0.3);
            transform: scale(0.95);
        }

        /* Cụm Zoom */
        .zoom-group {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .btn-zoom { width: 50px; height: 50px; font-size: 24px; font-weight: bold; }

        /* Nút Tấn công */
        .attack-group {
            position: absolute;
            bottom: 40px;
            right: 40px;
        }
        .btn-attack {
            width: 90px;
            height: 90px;
            font-size: 16px;
            font-weight: bold;
            border-width: 3px;
            box-shadow: 0 0 20px rgba(143, 255, 224, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    
    <div id="instructions" class="game-ui">Double Tap: Change Form • Hold Button: Attack</div>

    <div class="controls-layer">
        <div class="zoom-group">
            <div id="btn-zoom-in" class="btn btn-zoom">+</div>
            <div id="btn-zoom-out" class="btn btn-zoom">−</div>
        </div>

        <div class="attack-group">
            <div id="btn-attack" class="btn btn-attack">Công</div>
        </div>
    </div>

<script>
    /**
     * ====================================================================
     * 1. CONFIGURATION
     * ====================================================================
     */
    const CONFIG = {
        CORE: { BASE_WIDTH: 1920 },
        ZOOM: {
            MIN: 0.5,
            MAX: 3.0,
            SENSITIVITY: 0.001,
            STEP: 0.2, // Bước zoom khi nhấn nút
            SMOOTH: 0.1
        },
        SWORD: {
            COUNT: 72,
            BASE_RADIUS: 130,
            LAYER_SPACING: 70,
            SPIN_SPEED_BASE: 0.07,
            ATTACK_DELAY_MS: 180,
            TRAIL_LENGTH: 6,
            SIZE: 70,
        },
        INPUT: { DOUBLE_TAP_DELAY: 300 },
        COLORS: {
            BG_FADE: "rgba(0, 0, 8, 0.25)",
            SWORD_BLADE: ["#d0fff5", "#7fdcc0", "#3fa78a"],
            SWORD_TRAIL: "rgba(120, 255, 210, 0.3)",
        },
        ENEMY: {
            SPAWN_COUNT: 6,
            PALETTES: [
                ["#ff9999", "#cc3333"], ["#99ccff", "#3366cc"],
                ["#99ff99", "#33cc33"], ["#ffcc99", "#cc6600"],
                ["#ff99ff", "#cc33cc"], ["#ffff99", "#cccc33"]
            ]
        }
    };

    /**
     * ====================================================================
     * 2. SYSTEM & CAMERA
     * ====================================================================
     */
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });
    
    let scaleFactor = 1;
    let width, height;

    // Camera Object để quản lý Zoom
    const Camera = {
        currentZoom: 1,
        targetZoom: 1,
        
        update() {
            // Hiệu ứng easing (làm mượt)
            this.currentZoom += (this.targetZoom - this.currentZoom) * CONFIG.ZOOM.SMOOTH;
        },

        // Chuyển đổi tọa độ màn hình sang tọa độ thế giới game
        // Screen -> World
        screenToWorld(screenX, screenY) {
            const centerX = width / 2;
            const centerY = height / 2;
            return {
                x: (screenX - centerX) / this.currentZoom + centerX,
                y: (screenY - centerY) / this.currentZoom + centerY
            };
        },
        adjustZoom(amount) {
            this.targetZoom = Math.max(CONFIG.ZOOM.MIN, Math.min(CONFIG.ZOOM.MAX, this.targetZoom + amount));
        }
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        scaleFactor = width / CONFIG.CORE.BASE_WIDTH;
    }
    window.addEventListener("resize", resize);
    resize();

    /**
     * ====================================================================
     * 3. INPUT HANDLER (UPDATED FOR ZOOM)
     * ====================================================================
     */
    const Input = {
        screenX: width / 2, screenY: height / 2, // Tọa độ thực trên màn hình
        x: width / 2, y: height / 2,             // Tọa độ logic trong game (đã tính zoom)
        px: 0, py: 0,
        speed: 0,
        isAttacking: false,
        guardForm: 1,
        lastTapTime: 0,
        attackTimer: null,

        update() {
            // Cập nhật tọa độ logic dựa trên camera hiện tại
            const worldPos = Camera.screenToWorld(this.screenX, this.screenY);
            this.x = worldPos.x;
            this.y = worldPos.y;

            this.speed = Math.hypot(this.x - this.px, this.y - this.py);
            this.px = this.x; 
            this.py = this.y;
        },

        handleMove(e) {
            if (e.target.closest('.btn')) return; // Không di chuyển khi chạm nút
            const p = e.touches ? e.touches[0] : e;
            this.screenX = p.clientX;
            this.screenY = p.clientY;
        },

        handleDown(e) {
            if (e.target.closest('.btn')) return; // Không tính double tap khi bấm nút UI
            const now = performance.now();
            if (now - this.lastTapTime < CONFIG.INPUT.DOUBLE_TAP_DELAY) {
                this.guardForm = this.guardForm === 1 ? 2 : 1;
                this.isAttacking = false;
                this.lastTapTime = 0;
                return;
            }
            this.lastTapTime = now;
        }
    };

    // Gắn sự kiện cho các nút UI
    document.getElementById('btn-zoom-in').addEventListener('pointerdown', (e) => { e.stopPropagation(); Camera.adjustZoom(CONFIG.ZOOM.STEP); });
    document.getElementById('btn-zoom-out').addEventListener('pointerdown', (e) => { e.stopPropagation(); Camera.adjustZoom(-CONFIG.ZOOM.STEP); });
    
    const attackBtn = document.getElementById('btn-attack');
    const startAttack = (e) => { e.stopPropagation(); e.preventDefault(); Input.isAttacking = true; };
    const endAttack = (e) => { e.stopPropagation(); e.preventDefault(); Input.isAttacking = false; };
    
    attackBtn.addEventListener('touchstart', startAttack);
    attackBtn.addEventListener('touchend', endAttack);
    attackBtn.addEventListener('pointerdown', startAttack);
    attackBtn.addEventListener('pointerup', endAttack);

    // Sự kiện Canvas
    ['pointermove', 'touchmove'].forEach(evt => window.addEventListener(evt, e => Input.handleMove(e), { passive: false }));
    ['pointerdown', 'touchstart'].forEach(evt => window.addEventListener(evt, e => Input.handleDown(e), { passive: false }));
    window.addEventListener('wheel', e => Camera.adjustZoom(-e.deltaY * CONFIG.ZOOM.SENSITIVITY), { passive: false });

    /**
     * ====================================================================
     * 4. GAME ENTITIES
     * ====================================================================
     */
    const random = (min, max) => Math.random() * (max - min) + min;

    class Enemy {
        constructor() { this.respawn(); }
        respawn() {
            // Spawn ngẫu nhiên trong vùng rộng hơn màn hình một chút để khi zoom out vẫn thấy
            const margin = 500;
            this.x = random(-margin, width + margin);
            this.y = random(-margin, height + margin);
            this.r = (10 + Math.pow(Math.random(), 1.5) * 50) * scaleFactor; 
            this.maxHp = 1 + Math.floor(Math.random() * 100);
            this.hp = this.maxHp;
            this.colors = CONFIG.ENEMY.PALETTES[Math.floor(Math.random() * CONFIG.ENEMY.PALETTES.length)];
        }
        hit() {
            this.hp--;
            if (this.hp <= 0) { this.respawn(); return true; }
            return false;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            const g = ctx.createRadialGradient(0, 0, this.r * 0.2, 0, 0, this.r);
            g.addColorStop(0, this.colors[0]);
            g.addColorStop(1, this.colors[1]);
            ctx.beginPath();
            ctx.arc(0, 0, this.r, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.shadowColor = this.colors[1];
            ctx.shadowBlur = 15 * scaleFactor;
            ctx.fill();
            ctx.restore();
        }
    }

    class Sword {
        constructor(index) {
            this.index = index;
            this.layer = Math.floor(index / 24); 
            this.baseAngle = (Math.PI * 2 / 24) * (index % 24);
            this.spinAngle = 0;
            this.spinSpeed = (CONFIG.SWORD.SPIN_SPEED_BASE / (this.layer + 1)) * (this.layer % 2 ? -1 : 1);
            this.radius = (CONFIG.SWORD.BASE_RADIUS + this.layer * CONFIG.SWORD.LAYER_SPACING) * scaleFactor;
            this.x = Input.x; this.y = Input.y;
            this.vx = 0; this.vy = 0;
            this.drawAngle = 0;
            this.trail = [];
            this.breath = random(0, Math.PI * 2);
            this.breathSpeed = random(0.015, 0.025);
            this.attackDelay = this.layer * 6 + random(0, 10);
            this.attackFrame = 0;
            this.flowNoise = Math.random() * Math.PI * 2;
            this.flowOffsetAngle = (Math.PI * 2 / 72) * index; // Mỗi thanh 1 góc khác nhau để tạo vòng lượn
            this.flowOffsetRadius = (40 + Math.random() * 60) * scaleFactor; // Độ rộng vòng lượn
        }

        update(guardCenter, enemies) {
            this.breath += this.breathSpeed;
            const r = this.radius + Math.sin(this.breath) * 8 * scaleFactor;

            if (!Input.isAttacking) {
                this.spinAngle += this.spinSpeed;
                const a = this.baseAngle + this.spinAngle;
                const tx = guardCenter.x + Math.cos(a) * r;
                const ty = guardCenter.y + Math.sin(a) * r;

                if (Input.speed > 1.5) {
                    this.flowNoise += 0.04;
                    const fx = Input.x + Math.cos(this.flowOffsetAngle + this.flowNoise) * this.flowOffsetRadius;
                    const fy = Input.y + Math.sin(this.flowOffsetAngle + this.flowNoise) * this.flowOffsetRadius;
                    const dx = fx - this.x, dy = fy - this.y;
                    const d = Math.hypot(dx, dy) || 1;
                    this.vx += (dx / d) * Math.min(d * 0.04, 3 * scaleFactor);
                    this.vy += (dy / d) * Math.min(d * 0.04, 3 * scaleFactor);
                    this.vx *= 0.9; this.vy *= 0.9;
                    this.x += this.vx; this.y += this.vy;
                    this.drawAngle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
                } else {
                    this.x += (tx - this.x) * 0.12;
                    this.y += (ty - this.y) * 0.12;
                    this.vx *= 0.5; this.vy *= 0.5;
                    let targetAngle = (Input.guardForm === 1) ? a + Math.PI / 2 : Math.atan2(ty - this.y, tx - this.x) + Math.PI / 2;
                    let diff = targetAngle - this.drawAngle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.drawAngle += diff * 0.15;
                }
                this.attackFrame = 0; this.trail = [];
            } else {
                this.attackFrame++;
                if (this.attackFrame < this.attackDelay) return;
                let target = null, minDist = Infinity;
                for (const e of enemies) {
                    const d = Math.hypot(e.x - Input.x, e.y - Input.y);
                    if (d < minDist) { minDist = d; target = e; }
                }
                if (target) {
                    const dx = target.x - this.x, dy = target.y - this.y;
                    const d = Math.hypot(dx, dy) || 1;
                    this.vx += (dx / d) * 10 * scaleFactor;
                    this.vy += (dy / d) * 10 * scaleFactor;
                    this.vx *= 0.92; this.vy *= 0.92;
                    this.x += this.vx; this.y += this.vy;
                    this.drawAngle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
                    if (Math.hypot(this.x - target.x, this.y - target.y) < target.r) target.hit();
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > CONFIG.SWORD.TRAIL_LENGTH) this.trail.shift();
                }
            }
        }

        draw(ctx) {
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                ctx.strokeStyle = CONFIG.COLORS.SWORD_TRAIL;
                ctx.lineWidth = 2 * scaleFactor;
                ctx.stroke();
            }
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.drawAngle);
            this.drawBlade(ctx);
            ctx.restore();
        }

        drawBlade(ctx) {
            const sLen = CONFIG.SWORD.SIZE * scaleFactor;
            const sWid = 4 * scaleFactor;
            const g = ctx.createLinearGradient(0, -sLen, 0, 0);
            g.addColorStop(0, CONFIG.COLORS.SWORD_BLADE[0]);
            g.addColorStop(1, CONFIG.COLORS.SWORD_BLADE[2]);
            ctx.fillStyle = g;
            ctx.shadowColor = "#8fffe0"; ctx.shadowBlur = 10 * scaleFactor;
            ctx.beginPath();
            ctx.moveTo(-sWid / 2, 0);
            ctx.lineTo(-sWid / 2, -sLen);
            ctx.quadraticCurveTo(0, -sLen - 10 * scaleFactor, sWid / 2, -sLen);
            ctx.lineTo(sWid / 2, 0);
            ctx.fill();
        }
    }

    class StarField {
        constructor(count) {
            this.stars = [];
            for(let i=0; i<count; i++) {
                this.stars.push({ x: random(-width, width * 2), y: random(-height, height * 2), r: random(0.5, 2), alpha: random(0.2, 1) });
            }
        }
        draw(ctx) {
            for (const s of this.stars) {
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r * scaleFactor, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fill();
            }
        }
    }

    /**
     * ====================================================================
     * 5. MAIN MANAGER
     * ====================================================================
     */
    const enemies = [], swords = [];
    let starField;
    const guardCenter = { x: width/2, y: height/2, vx: 0, vy: 0 };

    function init() {
        starField = new StarField(250);
        for (let i = 0; i < CONFIG.ENEMY.SPAWN_COUNT; i++) enemies.push(new Enemy());
        for (let i = 0; i < CONFIG.SWORD.COUNT; i++) swords.push(new Sword(i));
    }

    function animate() {
        // 1. Xóa màn hình (Vẽ nền mờ) - Ở hệ tọa độ màn hình (Screen Space)
        ctx.fillStyle = CONFIG.COLORS.BG_FADE;
        ctx.fillRect(0, 0, width, height);

        Camera.update();
        Input.update();

        let dx = Input.x - guardCenter.x, dy = Input.y - guardCenter.y;
        guardCenter.vx = (guardCenter.vx + dx * 0.04) * 0.82;
        guardCenter.vy = (guardCenter.vy + dy * 0.04) * 0.82;
        guardCenter.x += guardCenter.vx; guardCenter.y += guardCenter.vy;

        ctx.save();
        // Dời gốc về giữa màn hình -> Zoom -> Trả gốc về
        ctx.translate(width / 2, height / 2);
        ctx.scale(Camera.currentZoom, Camera.currentZoom);
        ctx.translate(-width / 2, -height / 2);

        // --- Bắt đầu vẽ thế giới game (World Space) ---
        starField.draw(ctx);
        enemies.forEach(e => e.draw(ctx));
        swords.forEach(s => { s.update(guardCenter, enemies); s.draw(ctx); });

        ctx.restore();
        requestAnimationFrame(animate);
    }

    init();
    animate();

</script>
</body>
</html>